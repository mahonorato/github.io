(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{460:function(e,a,t){"use strict";t.r(a);var o=t(42),n=Object(o.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"powershell"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#powershell"}},[e._v("#")]),e._v(" PowerShell")]),e._v(" "),t("h2",{attrs:{id:"analise-de-arquivos-de-texto"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#analise-de-arquivos-de-texto"}},[e._v("#")]),e._v(" Análise de arquivos de texto")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    Hoje o tema é sobre os cmdlet’s Group-Object e Measure-Object e sobre a sua capacidade de analisar ficheiros baseados em texto.  O exemplo abaixo analisa o ficheiro windowsupdate.log e devolve o número de registos que o ficheiro contém agrupados por dia.\n    Get-Content $env:windir\\windowsupdate.log |   Group-Object { $_.SubString(0,10) } -NoElement |   Sort-Object Count -Descending |   Select-Object Count, Name\n    # Devolve o número de linhas\n        Get-Content C:\\windows\\WindowsUpdate.log | Measure-Object -Line\n        C:\\_SAIDA\\Transfer\\Faturamento\\Choice3a_Faturamento_2014_01_06.txt\n        Get-Content C:\\_SAIDA\\Transfer\\Faturamento\\Choice3a_Faturamento_2014_01_06.txt | Measure-Object -Line\n    # Devolve o número de palavras\n        Get-Content C:\\windows\\WindowsUpdate.log | Measure-Object -Word\n    # Devolve o número de caracteres\n        Get-Content C:\\windows\\WindowsUpdate.log | Measure-Object -Character\n    # Analisando as propriedades comprimento podemos ainda saber o comprimento máximo, mínimo, médio e a soma\n        Get-Content C:\\windows\\WindowsUpdate.log | Measure-Object -Property length -Maximum -Minimum -Average - Sum\n")])])]),t("h2",{attrs:{id:"how-do-i-change-the-extension-of-a-lot-of-files"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#how-do-i-change-the-extension-of-a-lot-of-files"}},[e._v("#")]),e._v(" How do I change the extension of a lot of files")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('    n PowerShell, it is better to use the Path.ChangeExtension method instead of -replace (thanks to Ohad Schneider for the remark):\n    Dir *.txt | rename-item -newname { [io.path]::ChangeExtension($_.name, ".c") }\n    For Linux (Bash):\n        for file in *.txt do mv "$file" "${file%.txt}.c" done\n')])])]),t("h2",{attrs:{id:"replace-or-delete-certain-characters-from-filenames-of-all-files-in-a-folder"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#replace-or-delete-certain-characters-from-filenames-of-all-files-in-a-folder"}},[e._v("#")]),e._v(" Replace or delete certain characters from filenames of all files in a folder")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('    Use PowerShell to do anything smarter for a DOS prompt. Here, I\'ve shown how to batch rename all the files and directories in the current directory that contain spaces by replacing them with _ underscores.\n    Dir | Rename-Item -NewName { $_.Name -replace " ","_" }\n    Optionally, the Where-Object command can be used to filter out ineligible objects for the successive cmdlet (command-let). The following are some examples to illustrate the flexibility it can afford you:\n    To skip any document files\n        Dir | Where-Object { $_.Name -notmatch "\\.(doc|xls|ppt)x?$" } | Rename-Item -NewName { $_.Name -replace " ","_" }\n    To process only directories (pre-3.0 version)\n        Dir | Where-Object { $_.Mode -match "^d" } | Rename-Item -NewName { $_.Name -replace " ","_" }\n    PowerShell v3.0 introduced new Dir flags. You can also use Dir -Directory there.\n    To skip any files already containing an underscore (or some other character)\n        Dir | Where-Object { -not $_.Name.Contains("_") } | Rename-Item -NewName { $_.Name -replace " ","_" }\n')])])])])}),[],!1,null,null,null);a.default=n.exports}}]);